/**********************************************************************************************************************
*   Attitude controller source file
*   this script contains functions used to generate inputs to the drone
*   that allow it to track the attitude reference from the RC or from the navigation controller
*   author: p. coppens
***********************************************************************************************************************/
#include "attitude.h"

/**
 *  this method is used during flying to get input based on a certain reference signal generated by
 *  the RC input or by the navigator
 *  the input is processed and turned into a control signal that stabilizes the drone around the attitude
 *  provided in the reference signal.
 *
 *  parameters:
 *      thrust:         the thrust provided by the rc or navigator (0..1)
 *      rot_x, rot_y    the requested roll and pitch provided by the rc or navigator (0..1 = [0..45DEG])
 *      rot_z           the requested yaw provided by the rc or navigator (0..1 = [0..360DEG])
 */
void controller_flying(float thrust, float rot_x, float rot_y, float rot_z) {
	load_input(thrust, rot_x, rot_y, rot_z);
	load_measurements();
	
	// Sample version of controller code that applies the rc inputs directly to the four motors
    v[0] = thrust; v[1] = rot_x; q[2] = rot_y; v[3] = rot_z; 

	// assign output
    if (thrust <= 0.01) {
    // if (1) { uncomment for calibration => directly apply signals to motors
    	PWMOutput((float)(CTR_OUT_LOW + (CTR_OUT_HIGH - CTR_OUT_LOW)*thrust), (float)(CTR_OUT_LOW + (CTR_OUT_HIGH - CTR_OUT_LOW)*thrust), (float)(CTR_OUT_LOW + (CTR_OUT_HIGH - CTR_OUT_LOW)*thrust), (float)(CTR_OUT_LOW + (CTR_OUT_HIGH - CTR_OUT_LOW)*thrust));
    } else {
    	PWMOutput((float)(CTR_OUT_LOW + (CTR_OUT_HIGH - CTR_OUT_LOW)*v[0]), (float)(CTR_OUT_LOW + (CTR_OUT_HIGH - CTR_OUT_LOW)*v[1]), (float)(CTR_OUT_LOW + (CTR_OUT_HIGH - CTR_OUT_LOW)*v[2]), (float)(CTR_OUT_LOW + (CTR_OUT_HIGH - CTR_OUT_LOW)*v[3]));
    }
}

/**
 *  this method is used to initiate the controller
 *  it does this by loading some initial values into the controller's and observer's states
 */
void controller_init() {

}

/**
 *  used instead controller_flying when the controller is disarmed
 *  it deactivates all engines
 */
void controller_idle() {
    // turn of all engines by dropping the voltage down to 0
	PWMOutput(0, 0, 0, 0);
}

/**
 *  this method is used to read in the measurements from the IMU and store them in variables
 *  that are used in the control calculations
 */
void load_measurements() {
	// get orientation measurement
	q[0] = ahrs_orient.w; q[1] = ahrs_orient.x; q[2] = ahrs_orient.y; q[3] = ahrs_orient.z;
	// get gyroscope measurement
	w[0] = gx; w[1] = gy; w[2] = gz;
	// get rotor frequency measurement
	// n[0] = nx; n[1] = ny; n[2] = nz;
}

/**
 *  this method reads the input from the rc or navigator and transforms the parameters to values
 *  that can be used by the controller
 *
 *  parameters:
 *      thrust:         the thrust provided by the rc or navigator (0..1)
 *      rot_x, rot_y    the requested roll and pitch provided by the rc or navigator (0..1 = [0..45DEG])
 *      rot_z           the requested yaw provided by the rc or navigator (0..1 = [0..360DEG])
 */
void load_input(float thrust, float rot_x, float rot_y, float rot_z) {
    // get the constant control value
	c = thrust;

	// get the relative rotation input
	if (thrust < 0.1)
		rel_yaw = 0.0;
	else if ((rot_z > 0.05) || (rot_z < -0.05))
		rel_yaw += 0.5 * rot_z * 2 * M_PI / TICKS_PS;

	// transform the reference input into radians
	float rx = rot_x * 45; float ry = rot_y * 45;
	CLAMP_INPLACE(rx, -10.0, 10.0); CLAMP_INPLACE(ry, -10.0, 10.0);

	rx = rx * M_PI / 180; ry = ry * M_PI / 180;

	// build the quaternion
	float d = rx*rx+ry*ry+rel_yaw*rel_yaw;
	float w = cos(sqrt(d)/2);
	float s;
	if(d==0)s=0;
	else s = sin(sqrt(d)/2)/sqrt(d);

	r[0] = w; r[1] = rx*s; r[2] = ry*s; r[3] = rel_yaw*s;
}

